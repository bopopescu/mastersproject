import os
import logging
from typing import (  # noqa
    Any,
    Coroutine,
    Generator,
    Generic,
    Iterable,
    List,
    Mapping,
    Optional,
    Set,
    Tuple,
    Type,
    TypeVar,
    Union,
)
from pathlib import Path

import porepy as pp
from porepy.fracs.simplex import tetrahedral_grid_from_gmsh
from porepy.fracs.meshing import grid_list_to_grid_bucket
import numpy as np
import scipy.sparse as sps

# --- LOGGING UTIL ---
try:
    from src.mastersproject.util.logging_util import timer, trace
except ImportError:
    from util.logging_util import timer, trace

logger = logging.getLogger(__name__)


@trace(logger)
def refine_mesh_by_splitting(
        in_file: Union[str, Path],
        out_file: Union[str, Path],
        dim: int,
        network: Union[pp.FractureNetwork3d, pp.FractureNetwork2d],
        gb_set_projections: bool = True,
) -> Generator[pp.GridBucket, None, None]:
    """ Refine a mesh by splitting using gmsh

    The method generates refinements on the fly by yielding GridBuckets as desired.

    Note:
    When the desired number of refinements is reached, you should call
        refine_mesh_by_splitting.close()
    so that gmsh.finalize() is called.

    Parameters
    ----------
    in_file : Union[str, Path]
        path to .geo file to read
    out_file : Union[str, Path]
        path to new .msh file to store mesh in, excluding the ending '.msh'.
    dim : int {2, 3}
        Dimension of domain to mesh
    network : Union[pp.FractureNetwork2d, pp.FractureNetwork3d]
        PorePy class defining the fracture network that is described by the .geo in_file
    gb_set_projections : bool (Default: True)
        Call pp.contact_conditions.set_projections(gb) before yielding result
    Returns
    -------
    Generator[gb]
        A generator for the refined grid buckets, starting with the coarsest.
    """
    # Ensure that in- and out paths are formatted correctly.
    assert Path(in_file).is_file()
    out_file = Path(out_file)
    out_file = out_file.parent / out_file.stem

    try:
        import gmsh
    except ModuleNotFoundError:
        raise ModuleNotFoundError(
            "To run gmsh python api on your system, "
            "download the relevant gmsh*-sdk.* from http://gmsh.info/bin/. "
            "Then, Add the 'lib' directory from the SDK to PYTHONPATH: \n"
            "export PYTHONPATH=${PYTHONPATH}:path/to/gmsh*-sdk.*/lib"
        )

    # gmsh must always be finalized after it has be initialized (see 'finally' clause).
    # Therefore, we wrap the entire function body in a try-finally context.
    try:
        # Initialize gmsh and generate the first (coarsest) mesh
        gmsh.initialize()
        gmsh.open(in_file)
        gmsh.model.mesh.generate(dim=dim)

        num_refinements = 0

        # Enter an infinite loop
        while True:
            out_file_name = f"{out_file}_{num_refinements}.msh"

            # The first mesh is already done. Start refining all subsequent meshes.
            if num_refinements > 0:
                gmsh.model.mesh.refine()  # Refine the mesh

            gmsh.write(out_file_name)  # Write the result to '.msh' file
            # Generate List[pp.Grid]
            grids = tetrahedral_grid_from_gmsh(network=network, file_name=out_file_name)
            # Convert List[pp.Grid] to pp.GridBucket
            gb = grid_list_to_grid_bucket(grids)

            # Set projection operators for mixed-dimensional grids
            if gb_set_projections:
                pp.contact_conditions.set_projections(gb)

            # yield the resulting grid bucket
            yield gb

            # finally, prepare the next iteration
            num_refinements += 1
    finally:
        # When refine_mesh_by_splitting.close() is called, we get here.
        gmsh.finalize()


@trace(logger)
def gb_coarse_fine_cell_mapping(gb: pp.GridBucket, gb_ref: pp.GridBucket, tol=1e-8):
    """ Wrapper for coarse_fine_cell_mapping to construct mapping for grids in
    GridBucket.

    Adds a node_prop to each grid in gb. The key is 'coarse_fine_cell_mapping',
    and is the mapping generated by 'coarse_fine_cell_mapping(...)'.

    Note: No node prop is added to the reference grids in gb_ref.

    Parameters
    ----------
    gb : pp.GridBucket
        Coarse grid bucket
    gb_ref : pp.GridBucket
        Refined grid bucket
    tol : float, Optional
        Tolerance for point_in_poly* -methods
    """

    grids = gb.get_grids()
    grids_ref = gb_ref.get_grids()

    assert len(grids) == len(
        grids_ref
    ), "Weakly check that GridBuckets refer to same domains"
    assert np.allclose(
        np.append(*gb.bounding_box()), np.append(*gb_ref.bounding_box())
    ), "Weakly check that GridBuckets refer to same domains"

    # This method assumes a consistent node ordering between grids. At least assign one.
    gb.assign_node_ordering(overwrite_existing=False)
    gb_ref.assign_node_ordering(overwrite_existing=False)

    # Add node prop on the coarse grid to map from coarse to fine cells.
    gb.add_node_props(keys="coarse_fine_cell_mapping")

    for i in np.arange(len(grids)):
        g, g_ref = grids[i], grids_ref[i]

        node_num, node_num_ref = (
            gb._nodes[g]["node_number"],
            gb_ref._nodes[g_ref]["node_number"],
        )
        assert node_num == node_num_ref, "Weakly check that grids refer to same domain."

        # Compute the mapping for this grid-pair,
        # and assign the result to the node of the coarse gb
        mapping = coarse_fine_cell_mapping(g, g_ref, point_in_poly_tol=tol)
        gb.set_node_prop(g=g, key="coarse_fine_cell_mapping", val=mapping)


@trace(logger)
def coarse_fine_cell_mapping(
        g: pp.Grid,
        g_ref: pp.Grid,
        tol=1e-8,
) -> sps.csc_matrix:
    """ Construct a mapping between cells of a grid and its refined version

    Assuming a regular and a refined mesh, where the refinement is executed by splitting.
    I.e. a cell in the refined grid is completely contained within a cell in the
    coarse grid.

    Parameters
    ----------
    g : pp.Grid
        Coarse grid
    g_ref : pp.Grid
        Refined grid
    tol : float, Optional
        Tolerance for pp.geometry_property_checks.point_in_polyhedron()

    Returns
    -------
    coarse_fine : sps.csc_matrix
        Column major sparse matrix mapping from coarse to fine cells.
    """

    assert g.num_cells < g_ref.num_cells, "Wrong order of input grids"
    assert g.dim == g_ref.dim, "Grids must be of same dimension"

    cell_nodes = g.cell_nodes()
    slices = zip(cell_nodes.indptr[:-1], cell_nodes.indptr[1:])  # start/end row pointers for each column

    # Create sps.csc_matrix mapping coarse cells to fine cell centers
    indptr = np.array([0])
    indices = np.empty(0)

    cells_ref = g_ref.cell_centers.copy()  # Cell centers in fine grid
    test_cells_ptr = np.arange(g_ref.num_cells)  # Pointer to cell centers
    nodes = g.nodes.copy()

    if g.dim == 1:
        nodes = nodes.copy()
        tangent = pp.map_geometry.compute_tangent(nodes)
        reference = [1, 0, 0]
        R = pp.map_geometry.project_line_matrix(nodes, tangent, tol=tol, reference=reference)
        nodes = R.dot(nodes)[0, :]
        cells_ref = R.dot(cells_ref)[0, :]

    elif g.dim == 2:  # Pre-processing for efficiency
        nodes = nodes.copy()
        R = pp.map_geometry.project_plane_matrix(nodes, check_planar=False)
        nodes = np.dot(R, nodes)[:2, :]
        cells_ref = np.dot(R, cells_ref)[:2, :]

    # Loop through every coarse cell
    for st, nd in slices:

        nodes_idx = cell_nodes.indices[st:nd]
        num_nodes = nodes_idx.size

        if g.dim == 1:
            assert (num_nodes == 2)
            line = np.sort(nodes[nodes_idx])
            test_points = cells_ref[test_cells_ptr]
            in_poly = np.searchsorted(line, test_points, side='left') == 1

        elif g.dim == 2:
            assert (num_nodes == 3), "We assume simplexes in 2D (i.e. 3 nodes)"
            polygon = nodes[:, nodes_idx]
            test_points = cells_ref[:, test_cells_ptr]
            in_poly = pp.geometry_property_checks.point_in_polygon(
                polygon, test_points, tol=tol)

        elif g.dim == 3:
            # Make polyhedron from node coordinates
            # Polyhedron defined as a list of nodes defining its (convex) faces.
            # Assumes simplexes: Every node except one defines every face.
            assert (num_nodes == 4), "We assume simplexes in 3D (i.e. 4 nodes)"
            node_coords = nodes[:, nodes_idx]

            ids = np.arange(num_nodes)
            polyhedron = [node_coords[:, ids != i] for i in np.arange(num_nodes)]
            test_points = cells_ref[:, test_cells_ptr]  # Test only points not inside another polyhedron.
            in_poly = pp.geometry_property_checks.point_in_polyhedron(
                polyhedron=polyhedron, test_points=test_points, tol=tol
            )

        else:
            logger.warning(f"A grid of dimension {g.dim} encountered. Skip!")
            continue

        # Update pointer to which cell centers to use as test points
        in_poly_ids = test_cells_ptr[in_poly]  # id of cells inside this polyhedron
        test_cells_ptr = test_cells_ptr[~in_poly]  # Keep only cells not inside this polyhedron

        # Update mapping
        indices = np.append(indices, in_poly_ids)
        indptr = np.append(indptr, indptr[-1] + in_poly_ids.size)

    data = np.ones(indices.size)

    coarse_fine = sps.csc_matrix((data, indices, indptr))

    assert (indices.size == g_ref.num_cells), "Every fine cell should be inside exactly one coarse cell"
    return coarse_fine
